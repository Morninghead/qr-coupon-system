<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <title>Advanced Card Template Editor</title>
    <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background-color: #f0f2f5; display: flex; gap: 30px; flex-wrap: wrap; }
        .editor-wrapper { display: flex; gap: 30px; width: 100%; }
        .controls { padding: 20px; background-color: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); width: 300px; height: fit-content; }
        .control-group { margin-bottom: 15px; }
        .control-group label, .control-group h3 { font-weight: 600; display: block; margin-bottom: 12px; color: #333; font-size: 1em; }
        .control-group button, .control-group input[type=file], .control-group select { width: 100%; padding: 8px; box-sizing: border-box; margin-bottom: 10px; }
        .control-group button { background-color: #6366F1; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        .control-group button:hover { background-color: #4f46e5; }
        .control-group button:disabled { background-color: #c7d2fe; cursor: not-allowed; }
        #export-json { background-color: #10B981; }
        #export-json:hover { background-color: #059669; }
        .history-buttons { display: flex; gap: 10px; }
        textarea { width: 100%; height: 150px; font-family: monospace; font-size: 12px; }
        .canvases { display: flex; gap: 30px; flex-wrap: wrap; }
        /* START: Added margin-top to move canvases down */
        .stage-wrapper { position: relative; margin-top: 50px; }
        /* END: Added margin-top */
        .canvas-container { padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; }
        .canvas-container.active { box-shadow: 0 2px 8px rgba(99, 102, 241, 0.5), 0 0 0 2px #6366F1; }
        .canvas-container h2 { margin-top: 0; font-size: 1.2em; color: #444; text-align: center; }
        .konvajs-content { border: 1px dashed #ccc; background-color: #fafafa; }
        .radio-group label, .checkbox-group label { display: inline-flex; align-items: center; margin-right: 15px; cursor: pointer; font-weight: normal; }
        #properties-panel { border-top: 1px solid #eee; padding-top: 15px; }
        .opacity-control, .font-size-control { display: flex; align-items: center; gap: 10px; }
        .opacity-control input[type=range] { flex-grow: 1; }
        .opacity-control input[type=number] { width: 60px; }
        .font-size-control input[type=number] { flex-grow: 1; }
        .font-size-control button { width: 40px; padding: 4px; margin: 0; }
        .ruler { position: absolute; background-color: #fdfdfd; overflow: hidden; display: none; }
        .ruler.horizontal { top: -25px; left: 0; height: 25px; }
        .ruler.vertical { top: 0; left: -25px; width: 25px; }
    </style>
</head>
<body>

    <div class="editor-wrapper">
        <div class="controls">
             <div class="control-group">
                <h3>History</h3>
                <div class="history-buttons">
                    <button id="undo-btn">Undo</button>
                    <button id="redo-btn">Redo</button>
                </div>
                <small><i>Tip: Press 'Delete' key to remove item.</i></small>
            </div>
            <hr>
            <div class="control-group">
                <h3>View Options</h3>
                <div class="checkbox-group">
                    <label><input type="checkbox" id="show-rulers"> Show Rulers</label>
                    <label><input type="checkbox" id="show-hole-mark"> Show Hole Mark</label>
                </div>
            </div>
            <hr>
            <div class="control-group">
                <h3>Card Orientation</h3>
                <div class="radio-group">
                    <label><input type="radio" name="orientation" value="landscape" checked> Landscape</label>
                    <label><input type="radio" name="orientation" value="portrait"> Portrait</label>
                </div>
            </div>
            <hr>
            <div class="control-group">
                <label for="bg-front-upload">Front Background</label>
                <input type="file" id="bg-front-upload" accept="image/*">
                <div class="opacity-control">
                    <input type="range" id="bg-opacity-slider" min="0" max="1" step="0.01" value="1">
                    <input type="number" id="bg-opacity-input" min="0" max="100" value="100"> %
                </div>
                <div class="checkbox-group">
                    <label><input type="checkbox" id="lock-background"> Lock Background</label>
                </div>
            </div>
            <div class="control-group">
                <label for="bg-back-upload">Back Background</label>
                <input type="file" id="bg-back-upload" accept="image/*">
            </div>
            <hr>
            <div class="control-group">
                <label>Add Elements (to Active Card)</label>
                <button id="add-photo">Add Employee Photo</button>
                <button id="add-name">Add Employee Name</button>
                <button id="add-id">Add Employee ID</button>
                <button id="add-logo">Add Company Logo</button>
                <button id="add-qr">Add QR Code</button>
            </div>
            <div id="properties-panel" class="control-group" style="display: none;"></div>
            <hr>
            <div class="control-group">
                <label>Export Layout</label>
                <button id="export-json">Export Layout as JSON</button>
                <textarea id="json-output" readonly placeholder="JSON output will appear here..."></textarea>
            </div>
        </div>
        <div class="canvases">
            <div class="stage-wrapper">
                <canvas id="ruler-vertical" class="ruler vertical"></canvas>
                <canvas id="ruler-horizontal" class="ruler horizontal"></canvas>
                <div class="canvas-container" id="front-container">
                    <h2>Front</h2>
                    <div id="stage-container-front"></div>
                </div>
            </div>
            <div class="stage-wrapper">
                 <div class="canvas-container" id="back-container">
                    <h2>Back</h2>
                    <div id="stage-container-back"></div>
                </div>
            </div>
        </div>
    </div>

<script>
    // --- 1. Constants & Initial Variables ---
    const STANDARD_RATIO = 85.6 / 54.0;
    const LANDSCAPE_WIDTH = 600; const LANDSCAPE_HEIGHT = LANDSCAPE_WIDTH / STANDARD_RATIO;
    const PORTRAIT_WIDTH = 400; const PORTRAIT_HEIGHT = PORTRAIT_WIDTH * STANDARD_RATIO;
    const HISTORY_LIMIT = 11; const SNAP_DISTANCE = 10;
    const FONT_FAMILIES = ['Arial', 'Calibri', 'Times New Roman', 'Sarabun', 'Kanit', 'Mitr', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC'];
    let activeStageInfo = null;
    const stages = {};
    const undoBtn = document.getElementById('undo-btn'), redoBtn = document.getElementById('redo-btn'), propertiesPanel = document.getElementById('properties-panel');
    const rulerH = document.getElementById('ruler-horizontal'), rulerV = document.getElementById('ruler-vertical');
    const rulerCtxH = rulerH.getContext('2d'), rulerCtxV = rulerV.getContext('2d');

    // --- 2. Main Initialization ---
    function initialize() {
        WebFont.load({ google: { families: FONT_FAMILIES.filter(f => !['Arial', 'Calibri', 'Times New Roman'].includes(f)) } });
        stages.front = setupNewStage('stage-container-front', LANDSCAPE_WIDTH, LANDSCAPE_HEIGHT);
        stages.back = setupNewStage('stage-container-back', LANDSCAPE_WIDTH, LANDSCAPE_HEIGHT);
        setActiveStage(stages.front);
        setupRulers();
        setupAllEventListeners();
        saveAllHistories();
    }

    function setupNewStage(containerId, width, height) {
        const stage = new Konva.Stage({ container: containerId, width, height });
        stage.container().style.cursor = 'default';
        stage.add(new Konva.Layer(), new Konva.Layer(), new Konva.Layer());
        const transformer = new Konva.Transformer({
            borderStroke: '#6366F1', anchorStroke: '#6366F1', anchorFill: 'white',
            boundBoxFunc: (oldBox, newBox) => {
                const node = transformer.nodes()[0];
                if (node && (node.hasName('photo') || node.hasName('logo'))) {
                    const ratio = oldBox.width / oldBox.height;
                    if (Math.abs(newBox.width) < 10 || Math.abs(newBox.height) < 10) return oldBox;
                    newBox.height = Math.abs(newBox.width / ratio);
                }
                return newBox;
            }
        });
        stage.getLayers()[1].add(transformer);
        const stageInfo = { stage, transformer, history: [], historyStep: -1 };
        transformer.on('transformend', () => saveStateFor(stageInfo));
        return stageInfo;
    }

    function setActiveStage(stageInfo) {
        if (activeStageInfo === stageInfo) return;
        activeStageInfo = stageInfo;
        document.getElementById('front-container').classList.toggle('active', activeStageInfo === stages.front);
        document.getElementById('back-container').classList.toggle('active', activeStageInfo === stages.back);
        updateHistoryButtons();
        updatePropertiesPanel();
    }

    // --- 3. History (Undo/Redo) Management ---
    function saveStateFor(stageInfo) {
        let { history } = stageInfo;
        if (stageInfo.historyStep < history.length - 1) history.splice(stageInfo.historyStep + 1);
        history.push(stageInfo.stage.getLayers()[1].toJSON());
        if (history.length > HISTORY_LIMIT) history.shift();
        stageInfo.historyStep = history.length - 1;
        updateHistoryButtons();
    }
    function saveAllHistories() { Object.values(stages).forEach(saveStateFor); }
    function loadStateFor(stageInfo, stateJSON) {
        stageInfo.transformer.nodes([]);
        stageInfo.stage.getLayers()[1].destroy();
        const newLayer = Konva.Node.create(stateJSON);
        stageInfo.stage.add(newLayer);
        newLayer.add(stageInfo.transformer);
        newLayer.find('Rect, Text, Circle, Ellipse').forEach(node => {
            node.on('dragend', () => saveStateFor(stageInfo));
            node.on('dragmove', e => handleDragMove(e, stageInfo));
        });
    }
    function undo() { if (activeStageInfo.historyStep > 0) { activeStageInfo.historyStep--; loadStateFor(activeStageInfo, activeStageInfo.history[activeStageInfo.historyStep]); updateHistoryButtons(); } }
    function redo() { if (activeStageInfo.historyStep < activeStageInfo.history.length - 1) { activeStageInfo.historyStep++; loadStateFor(activeStageInfo, activeStageInfo.history[activeStageInfo.historyStep]); updateHistoryButtons(); } }
    function updateHistoryButtons() {
        if (!activeStageInfo) return;
        undoBtn.disabled = activeStageInfo.historyStep <= 0;
        redoBtn.disabled = activeStageInfo.historyStep >= activeStageInfo.history.length - 1;
    }

    // --- 4. Rulers, Guides & Snapping ---
    function setupRulers() { drawRulers(); }
    function drawRulers() {
        const { width, height } = stages.front.stage.size();
        rulerH.width = width; rulerH.height = 25; rulerV.width = 25; rulerV.height = height;
        [rulerCtxH, rulerCtxV].forEach(ctx => { ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); ctx.strokeStyle = '#ccc'; ctx.fillStyle = '#666'; ctx.font = '10px sans-serif'; });
        for (let i = 0; i <= width; i+=10) { const h = (i % 50 === 0) ? 10 : 5; rulerCtxH.beginPath(); rulerCtxH.moveTo(i, 25); rulerCtxH.lineTo(i, 25 - h); rulerCtxH.stroke(); if (i % 50 === 0 && i > 0) rulerCtxH.fillText(i, i + 2, 12); }
        for (let i = 0; i <= height; i+=10) { const w = (i % 50 === 0) ? 10 : 5; rulerCtxV.beginPath(); rulerCtxV.moveTo(25, i); rulerCtxV.lineTo(25 - w, i); rulerCtxV.stroke(); if (i % 50 === 0 && i > 0) { rulerCtxV.save(); rulerCtxV.translate(12, i + 2); rulerCtxV.rotate(-Math.PI / 2); rulerCtxV.fillText(i, 0, 0); rulerCtxV.restore(); }}
    }
    function getSnapLines(stageInfo) {
        const { width, height } = stageInfo.stage.size();
        const lines = { vertical: [width/2], horizontal: [height/2] };
        stageInfo.stage.getLayers()[1].children.forEach(node => {
            if (node === stageInfo.transformer || !node.isVisible() || stageInfo.transformer.nodes().includes(node)) return;
            const box = node.getClientRect({ relativeTo: stageInfo.stage });
            lines.vertical.push(box.x, box.x + box.width, box.x + box.width / 2);
            lines.horizontal.push(box.y, box.y + box.height, box.y + box.height / 2);
        });
        return lines;
    }
    function getObjectSnappingEdges(node, stageInfo) {
        const box = node.getClientRect({ relativeTo: stageInfo.stage });
        return { vertical: [box.x, box.x + box.width/2, box.x + box.width], horizontal: [box.y, box.y + box.height/2, box.y + box.height] };
    }
    function handleDragMove(e, stageInfo) {
        const target = e.target, guidesLayer = stageInfo.stage.getLayers()[2];
        guidesLayer.destroyChildren();
        const lines = getSnapLines(stageInfo), edges = getObjectSnappingEdges(target, stageInfo);
        lines.vertical.forEach(g => edges.vertical.forEach(e => { if (Math.abs(e - g) < SNAP_DISTANCE) { target.x(target.x() - (e - g)); drawGuide(g, 'vertical', stageInfo); } }));
        lines.horizontal.forEach(g => edges.horizontal.forEach(e => { if (Math.abs(e - g) < SNAP_DISTANCE) { target.y(target.y() - (e - g)); drawGuide(g, 'horizontal', stageInfo); } }));
    }
    function drawGuide(value, orientation, stageInfo) {
        const stage = stageInfo.stage;
        const points = orientation === 'vertical' ? [value, 0, value, stage.height()] : [0, value, stage.width(), value];
        stage.getLayers()[2].add(new Konva.Line({ points, stroke: 'rgba(255, 0, 0, 0.6)', strokeWidth: 1, dash: [4, 6] }));
    }
    
    // --- 5. Background, Opacity & Orientation ---
    function setBackground(imageSrc, layer, width, height, opacity) {
        layer.destroyChildren();
        const img = new Image();
        img.onload = () => layer.add(new Konva.Image({ image: img, width, height, name: 'background', opacity, draggable: false }));
        img.src = imageSrc;
    }
    function handleOrientationChange() {
        const isLandscape = document.querySelector('input[name="orientation"]:checked').value === 'landscape';
        const newSize = { width: isLandscape ? LANDSCAPE_WIDTH : PORTRAIT_WIDTH, height: isLandscape ? LANDSCAPE_HEIGHT : PORTRAIT_HEIGHT };
        Object.values(stages).forEach(s => {
            s.stage.size(newSize);
            s.stage.findOne('.background')?.size(newSize);
            const hole = s.stage.findOne('.hole-mark');
            if(hole) hole.position(isLandscape ? {x: newSize.width - 30, y: newSize.height / 2} : {x: newSize.width / 2, y: 15});
        });
        drawRulers();
    }
    function addHoleMark(stageInfo) {
        const { stage } = stageInfo;
        const isLandscape = stage.width() > stage.height();
        const hole = new Konva.Ellipse({
            x: isLandscape ? stage.width() - 30 : stage.width() / 2,
            y: isLandscape ? stage.height() / 2 : 15,
            radiusX: 14, radiusY: 3,
            fill: 'rgba(255,255,255,0.8)', stroke: 'rgba(0,0,0,0.3)', strokeWidth: 1,
            name: 'hole-mark', visible: document.getElementById('show-hole-mark').checked
        });
        stage.getLayers()[2].add(hole);
    }

    // --- 6. Element Creation, Properties Panel & Event Handling ---
    function addElement(type) {
        let element;
        const { stage, transformer } = activeStageInfo;
        const commonProps = { x: 50, y: 50, draggable: true, name: type };
        switch(type) {
            case 'photo': element = new Konva.Circle({ ...commonProps, radius: 75, fill: '#e0e0e0', stroke: '#bdbdbd', strokeWidth: 2, name: 'photo' }); break;
            case 'name': element = new Konva.Text({ ...commonProps, text: 'Employee Name', fontSize: 32, fontFamily: 'Sarabun', fill: 'black', name: 'employee_name' }); break;
            case 'id': element = new Konva.Text({ ...commonProps, text: '12345', fontSize: 24, fontFamily: 'Sarabun', fill: '#424242', name: 'employee_id' }); break;
            case 'logo': element = new Konva.Rect({ ...commonProps, width: 100, height: 50, fill: '#e0e0e0', stroke: '#bdbdbd', strokeWidth: 1, name: 'logo' }); break;
            case 'qr': element = new Konva.Rect({ ...commonProps, width: 120, height: 120, fill: '#e0e0e0', name: 'qr_code' }); break;
        }
        if (element) {
            element.on('dragmove', e => handleDragMove(e, activeStageInfo));
            stage.getLayers()[1].add(element);
            transformer.nodes([element]);
            saveStateFor(activeStageInfo);
            updatePropertiesPanel();
        }
    }
    function updatePropertiesPanel() {
        const selectedNodes = activeStageInfo ? activeStageInfo.transformer.nodes() : [];
        const node = selectedNodes[0];
        propertiesPanel.style.display = 'none'; propertiesPanel.innerHTML = '';
        if (selectedNodes.length !== 1) return;
        
        propertiesPanel.style.display = 'block';
        let content = `<h3>${node.name()} Properties</h3>`;
        if (node.hasName('photo') || node.hasName('logo')) content += `<label>Upload Image</label><input type="file" class="element-image-upload" accept="image/*">`;
        if (node.hasName('photo')) content += `<label>Photo Shape</label><div class="radio-group"><label><input type="radio" name="photoShape" value="circle" ${node.getClassName()==='Circle'?'checked':''}> Circle</label><label><input type="radio" name="photoShape" value="rect" ${node.getClassName()==='Rect'?'checked':''}> Rectangle</label></div>`;
        if (node.getClassName() === 'Text') content += `<label>Font Family</label><select class="font-family-select">${FONT_FAMILIES.map(f => `<option value="${f}" ${node.fontFamily()===f?'selected':''}>${f}</option>`).join('')}</select><label>Font Size</label><div class="font-size-control"><button class="font-size-dec">-</button><input type="number" class="font-size-input" value="${node.fontSize()}"><button class="font-size-inc">+</button></div>`;
        propertiesPanel.innerHTML = content;
        attachPropertiesListeners();
    }
    function attachPropertiesListeners() {
        const imageUpload = propertiesPanel.querySelector('.element-image-upload');
        if (imageUpload) imageUpload.addEventListener('change', handleElementImageUpload);
        propertiesPanel.querySelectorAll('input[name="photoShape"]').forEach(radio => radio.addEventListener('change', handlePhotoShapeChange));
        const fontFamilySelect = propertiesPanel.querySelector('.font-family-select');
        if (fontFamilySelect) fontFamilySelect.addEventListener('change', handleFontChange);
        const fontSizeInput = propertiesPanel.querySelector('.font-size-input');
        if (fontSizeInput) {
            fontSizeInput.addEventListener('change', handleFontChange);
            propertiesPanel.querySelector('.font-size-dec').addEventListener('click', () => { fontSizeInput.value = parseInt(fontSizeInput.value) - 1; handleFontChange(); });
            propertiesPanel.querySelector('.font-size-inc').addEventListener('click', () => { fontSizeInput.value = parseInt(fontSizeInput.value) + 1; handleFontChange(); });
        }
    }
    function handleElementImageUpload(e) {
        const node = activeStageInfo.transformer.nodes()[0];
        if (!node || !e.target.files[0]) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                node.fill(null); node.fillPatternImage(img); node.fillPatternRepeat('no-repeat');
                
                if (node.getClassName() === 'Circle' && node.hasName('photo')) {
                    // START: Fix for Circle image positioning
                    const radius = node.radius();
                    const diameter = radius * 2;
                    const ratio = img.width / img.height;
                    let scale;
                    // Scale to cover logic
                    if (ratio > 1) { // Landscape image
                        scale = diameter / img.height;
                    } else { // Portrait or square image
                        scale = diameter / img.width;
                    }
                    const scaledWidth = img.width * scale;

                    // Set scale and offset to align top-center of image with circle center
                    node.fillPatternScale({ x: scale, y: scale });
                    node.fillPatternOffset({ x: scaledWidth / 2, y: 0 }); // Offset is relative to top-left of pattern
                
                } else { // Rectangle (Logo) logic
                    const currentWidth = node.width() * node.scaleX();
                    const ratio = img.width / img.height;
                    const newHeight = currentWidth / ratio;
                    node.size({ width: currentWidth, height: newHeight });
                    node.scale({x: 1, y: 1});
                    node.fillPatternScale({ x: currentWidth / img.width, y: newHeight / img.height });
                }
                
                saveStateFor(activeStageInfo);
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(e.target.files[0]);
    }
    function handlePhotoShapeChange(e) {
        const oldShape = activeStageInfo.transformer.nodes()[0]; if (!oldShape) return;
        const isCircle = e.target.value === 'circle';
        const attrs = oldShape.getAttrs(); delete attrs.radius; delete attrs.cornerRadius;
        const newShape = isCircle ? new Konva.Circle(attrs) : new Konva.Rect(attrs);
        if (isCircle) newShape.radius((oldShape.width() * oldShape.scaleX()) / 2);
        oldShape.destroy();
        activeStageInfo.stage.getLayers()[1].add(newShape);
        newShape.on('dragmove', ev => handleDragMove(ev, activeStageInfo));
        activeStageInfo.transformer.nodes([newShape]);
        saveStateFor(activeStageInfo);
    }
    function handleFontChange() {
        const node = activeStageInfo.transformer.nodes()[0]; if (!node) return;
        node.fontSize(parseInt(propertiesPanel.querySelector('.font-size-input').value));
        node.fontFamily(propertiesPanel.querySelector('.font-family-select').value);
        saveStateFor(activeStageInfo);
    }

    // --- 7. Main Event Listeners Setup ---
    function setupAllEventListeners() {
        undoBtn.addEventListener('click', undo); redoBtn.addEventListener('click', redo);
        document.getElementById('show-rulers').addEventListener('change', e => { rulerH.style.display = rulerV.style.display = e.target.checked ? 'block' : 'none'; });
        document.getElementById('show-hole-mark').addEventListener('change', e => Object.values(stages).forEach(s => { const m = s.stage.findOne('.hole-mark'); if(m) m.visible(e.target.checked); else if(e.target.checked) addHoleMark(s); }));
        document.querySelectorAll('input[name="orientation"]').forEach(radio => radio.addEventListener('change', handleOrientationChange));
        ['photo', 'name', 'id', 'logo', 'qr'].forEach(type => document.getElementById(`add-${type}`).addEventListener('click', () => addElement(type)));
        
        Object.entries(stages).forEach(([key, stageInfo]) => {
            document.getElementById(`${key}-container`).addEventListener('click', () => setActiveStage(stageInfo));
            stageInfo.stage.on('click tap', e => {
                if (e.target === stageInfo.stage || e.target.hasName('background')) stageInfo.transformer.nodes([]);
                else if (e.target.getParent() === stageInfo.stage.getLayers()[1]) stageInfo.transformer.nodes([e.target]);
                updatePropertiesPanel();
            });
        });

        window.addEventListener('keydown', e => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                const selectedNodes = activeStageInfo.transformer.nodes();
                if (selectedNodes.length > 0) { e.preventDefault(); selectedNodes.forEach(n => n.destroy()); activeStageInfo.transformer.nodes([]); saveStateFor(activeStageInfo); updatePropertiesPanel(); }
            }
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
            if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
        });
        const frontReader = new FileReader();
        frontReader.onload = e => setBackground(e.target.result, stages.front.stage.getLayers()[0], stages.front.stage.width(), stages.front.stage.height(), parseFloat(document.getElementById('bg-opacity-slider').value));
        document.getElementById('bg-front-upload').addEventListener('change', e => e.target.files[0] && frontReader.readAsDataURL(e.target.files[0]));
        const backReader = new FileReader();
        backReader.onload = e => setBackground(e.target.result, stages.back.stage.getLayers()[0], stages.back.stage.width(), stages.back.stage.height(), 1);
        document.getElementById('bg-back-upload').addEventListener('change', e => e.target.files[0] && backReader.readAsDataURL(e.target.files[0]));
        const bgOpacitySlider = document.getElementById('bg-opacity-slider'), bgOpacityInput = document.getElementById('bg-opacity-input');
        function updateBgOpacity(value) {
            const bg = stages.front.stage.getLayers()[0].findOne('.background');
            if (bg) bg.opacity(value);
            bgOpacitySlider.value = value; bgOpacityInput.value = Math.round(value * 100);
        }
        bgOpacitySlider.addEventListener('input', e => updateBgOpacity(parseFloat(e.target.value)));
        bgOpacityInput.addEventListener('change', e => updateBgOpacity(parseInt(e.target.value) / 100));
        document.getElementById('lock-background').addEventListener('change', e => { const bg = stages.front.stage.getLayers()[0].findOne('.background'); if(bg) bg.draggable(!e.target.checked); });
        document.getElementById('export-json').addEventListener('click', exportJSON);
    }
    
    // --- 8. Export to JSON ---
    function exportJSON() {
        const finalConfig = {};
        ['front', 'back'].forEach(side => {
            const stageInfo = stages[side];
            const layoutConfig = {};
            const { width: cardWidth, height: cardHeight } = stageInfo.stage.size();
            stageInfo.stage.getLayers()[1].children.forEach(node => {
                if (node === stageInfo.transformer || !node.name()) return;
                const scaleX = node.scaleX(), scaleY = node.scaleY();
                let width = node.width(), height = node.height();
                if(node.getClassName() === 'Circle') width = height = node.radius() * 2;
                const config = {
                    left: `${(node.x() / cardWidth * 100).toFixed(2)}%`, top: `${(node.y() / cardHeight * 100).toFixed(2)}%`,
                    width: `${(width * scaleX / cardWidth * 100).toFixed(2)}%`, height: `${(height * scaleY / cardHeight * 100).toFixed(2)}%`
                };
                if (node.rotation()) config.transform = `rotate(${node.rotation().toFixed(2)}deg)`;
                if (node.hasName('photo')) {
                    config.objectFit = 'cover';
                    if (node.getClassName() === 'Circle') config.borderRadius = '50%';
                }
                layoutConfig[node.name().replace(/_[0-9]+$/, '')] = config;
            });
            finalConfig[`${side}Layout`] = layoutConfig;
        });
        document.getElementById('json-output').value = JSON.stringify(finalConfig, null, 2);
        alert('Layout JSON has been generated!');
    }

    // --- Run Application ---
    initialize();
</script>
</body>
</html>